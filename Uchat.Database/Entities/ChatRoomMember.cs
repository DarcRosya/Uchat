/*
 * ============================================================================
 * ENTITY MODEL: CHATROOMME MBER (Участник группового чата)
 * ============================================================================
 * 
 * ЭТО ОЧЕНЬ ВАЖНАЯ КОНЦЕПЦИЯ - ПРОМЕЖУТОЧНАЯ ТАБЛИЦА!
 * 
 * В FastAPI/SQLAlchemy ты мог видеть это так:
 * 
 *   # Простая Many-to-Many через association table
 *   chat_members = Table('chat_members',
 *       Column('chat_id', ForeignKey('chats.id')),
 *       Column('user_id', ForeignKey('users.id'))
 *   )
 * 
 * Но что если нам нужно хранить ДОПОЛНИТЕЛЬНЫЕ ДАННЫЕ о связи?
 * - Когда пользователь присоединился к группе?
 * - Какая у него роль (админ, модератор)?
 * - Кто его пригласил?
 * - Заблокирован ли он в этой группе?
 * 
 * Для этого нужна ПОЛНОЦЕННАЯ МОДЕЛЬ, а не просто таблица связей!
 * 
 * Это называется "Association Object Pattern" или "Rich Many-to-Many".
 * 
 * ============================================================================
 * СХЕМА СВЯЗЕЙ:
 * ============================================================================
 * 
 *   User (1) <-----> (Many) ChatRoomMember (Many) <-----> (1) ChatRoom
 * 
 *   Один пользователь может быть в МНОГИХ группах
 *   Одна группа может иметь МНОГИХ участников
 *   ChatRoomMember хранит информацию об этой связи
 * 
 * ============================================================================
 */

namespace Uchat.Database.Entities;

/// <summary>
/// Участник группового чата (промежуточная таблица с дополнительными данными)
/// Представляет таблицу ChatRoomMembers в базе данных
/// 
/// Эта таблица соединяет Users и ChatRooms в отношении Many-to-Many
/// </summary>
public class ChatRoomMember
{
    // ========================================================================
    // PRIMARY KEY
    // ========================================================================
    
    /// <summary>
    /// Уникальный ID записи о членстве
    /// В БД: INTEGER PRIMARY KEY AUTOINCREMENT
    /// 
    /// ВАЖНО: Это НЕ UserId и НЕ ChatRoomId!
    /// Это отдельный ID для самой записи о членстве.
    /// 
    /// Зачем нужен отдельный Id?
    /// - Можно легко ссылаться на конкретное членство
    /// - Упрощает обновление и удаление
    /// - Следует best practices EF Core
    /// </summary>
    public int Id { get; set; }
    
    // ========================================================================
    // FOREIGN KEYS (Связи)
    // ========================================================================
    
    /// <summary>
    /// ID группового чата
    /// Foreign Key -> ChatRooms.Id
    /// В БД: INTEGER NOT NULL
    /// </summary>
    public int ChatRoomId { get; set; }
    
    /// <summary>
    /// ID пользователя (участника)
    /// Foreign Key -> Users.Id
    /// В БД: INTEGER NOT NULL
    /// </summary>
    public int UserId { get; set; }
    
    // ========================================================================
    // РОЛЬ В ГРУППЕ
    // ========================================================================
    
    /// <summary>
    /// Роль участника в этой группе
    /// В БД: INTEGER NOT NULL
    /// 
    /// Member = 0 (обычный участник)
    /// Moderator = 1 (может банить, удалять сообщения)
    /// Admin = 2 (может менять настройки группы, назначать модераторов)
    /// Owner = 3 (создатель, полный контроль, не может быть кикнут)
    /// </summary>
    public ChatRoomRole Role { get; set; }
    
    // ========================================================================
    // ВРЕМЕННЫЕ МЕТКИ
    // ========================================================================
    
    /// <summary>
    /// Когда пользователь присоединился к группе
    /// В БД: DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
    /// 
    /// Полезно для:
    /// - Сортировки участников (кто раньше вступил)
    /// - Статистики (сколько человек присоединилось за месяц)
    /// - Ограничений (новички не могут писать первые 24 часа)
    /// </summary>
    public DateTime JoinedAt { get; set; }
    
    /// <summary>
    /// Когда пользователь покинул группу (если покинул)
    /// В БД: DATETIME NULL
    /// 
    /// NULL = пользователь все еще в группе
    /// NOT NULL = пользователь вышел
    /// 
    /// ЗАЧЕМ ХРАНИТЬ ВЫШЕДШИХ УЧАСТНИКОВ?
    /// - История: кто раньше был в группе
    /// - Статистика: сколько человек ушло
    /// - Повторное вступление: проверка, был ли пользователь раньше
    /// - Возможность восстановить членство
    /// 
    /// Альтернатива: физически удалять запись при выходе
    /// (в этом случае LeftAt не нужен)
    /// </summary>
    public DateTime? LeftAt { get; set; }
    
    // ========================================================================
    // ПРИГЛАШЕНИЕ
    // ========================================================================
    
    /// <summary>
    /// ID пользователя, который пригласил этого участника в группу
    /// Foreign Key -> Users.Id
    /// В БД: INTEGER NULL
    /// 
    /// NULL = присоединился сам (публичная группа) или создатель группы
    /// 
    /// Полезно для:
    /// - Истории: кто кого пригласил (граф приглашений)
    /// - Ответственность: если пригласил спамера, можно понять кто виноват
    /// - Статистика: кто активно приглашает людей
    /// </summary>
    public int? InvitedById { get; set; }
    
    // ========================================================================
    // МОДЕРАЦИЯ
    // ========================================================================
    
    /// <summary>
    /// Заблокирован ли участник в этой группе (mute/ban)
    /// В БД: BOOLEAN NOT NULL DEFAULT 0
    /// 
    /// true = не может писать сообщения в группе
    /// false = может писать
    /// 
    /// Это НЕ кик из группы! Участник остается в группе, но молчит.
    /// </summary>
    public bool IsMuted { get; set; }
    
    /// <summary>
    /// До какого времени заблокирован
    /// В БД: DATETIME NULL
    /// 
    /// NULL = заблокирован навсегда (или не заблокирован)
    /// NOT NULL = временный бан
    /// 
    /// Проверка:
    ///   if (member.IsMuted && member.MutedUntil < DateTime.UtcNow) {
    ///       // Бан истек, можно разблокировать
    ///       member.IsMuted = false;
    ///       member.MutedUntil = null;
    ///   }
    /// </summary>
    public DateTime? MutedUntil { get; set; }
    
    // ========================================================================
    // НАВИГАЦИОННЫЕ СВОЙСТВА
    // ========================================================================
    
    /// <summary>
    /// Групповой чат
    /// Navigation property для ChatRoomId
    /// 
    /// Использование:
    ///   var member = await context.ChatRoomMembers
    ///       .Include(m => m.ChatRoom)
    ///       .FirstAsync(m => m.Id == 10);
    ///   
    ///   Console.WriteLine($"Участник группы: {member.ChatRoom.Name}");
    /// </summary>
    public ChatRoom ChatRoom { get; set; } = null!;
    
    /// <summary>
    /// Пользователь (участник)
    /// Navigation property для UserId
    /// 
    /// Использование:
    ///   var members = await context.ChatRoomMembers
    ///       .Include(m => m.User)
    ///       .Where(m => m.ChatRoomId == 5)
    ///       .ToListAsync();
    ///   
    ///   foreach (var member in members) {
    ///       Console.WriteLine($"{member.User.Username} - {member.Role}");
    ///   }
    /// </summary>
    public User User { get; set; } = null!;
    
    /// <summary>
    /// Пользователь, который пригласил
    /// Navigation property для InvitedById
    /// 
    /// User? потому что может быть NULL
    /// </summary>
    public User? InvitedBy { get; set; }
}

// ============================================================================
// ENUM: CHATROOM ROLE (Роль в групповом чате)
// ============================================================================

/// <summary>
/// Роль участника в групповом чате
/// Хранится в БД как INTEGER
/// </summary>
public enum ChatRoomRole
{
    /// <summary>
    /// Обычный участник
    /// - Может писать сообщения
    /// - Может читать сообщения
    /// - Может покинуть группу
    /// </summary>
    Member = 0,
    
    /// <summary>
    /// Модератор
    /// - Все права Member
    /// - Может удалять сообщения других
    /// - Может банить участников
    /// - Может закреплять сообщения
    /// </summary>
    Moderator = 1,
    
    /// <summary>
    /// Администратор
    /// - Все права Moderator
    /// - Может менять настройки группы
    /// - Может назначать модераторов
    /// - Может менять название и описание группы
    /// - Может удалять участников
    /// </summary>
    Admin = 2,
    
    /// <summary>
    /// Владелец (создатель группы)
    /// - Все права Admin
    /// - Может передать владение другому
    /// - Может удалить группу полностью
    /// - Не может быть кикнут из группы
    /// - Может назначать администраторов
    /// </summary>
    Owner = 3
}

/*
 * ============================================================================
 * ЗАДАНИЕ ДЛЯ ТЕБЯ (ПРАКТИКА):
 * ============================================================================
 * 
 * 1. Добавь поддержку КАСТОМНЫХ РОЛЕЙ:
 *    Создай новую таблицу CustomChatRoomRole:
 *    - Id (int)
 *    - ChatRoomId (int, FK)
 *    - Name (string) - например "Дизайнер", "Тестировщик"
 *    - Permissions (string) - JSON с правами: {"canDelete": true, "canPin": false}
 *    
 *    Добавь в ChatRoomMember:
 *    - CustomRoleId (int?, FK)
 * 
 * 2. Добавь СТАТИСТИКУ участника:
 *    - MessageCount (int) - сколько сообщений отправил в этой группе
 *    - LastMessageAt (DateTime?) - когда последний раз писал
 *    Обновляй при каждом новом сообщении
 * 
 * 3. Добавь УВЕДОМЛЕНИЯ:
 *    - NotificationsEnabled (bool) - получать ли уведомления от этой группы
 *    - NotificationSound (string?) - кастомный звук уведомления
 *    Позволит настроить уведомления для каждой группы отдельно
 * 
 * 4. Добавь ЗАМЕТКИ О УЧАСТНИКЕ:
 *    - Notes (string?) - приватные заметки о участнике (видны только админам)
 *    Полезно для модерации (пометить подозрительных)
 * 
 * ============================================================================
 * ВАЖНЫЕ SQL CONSTRAINTS:
 * ============================================================================
 * 
 * В DbContext нужно добавить UNIQUE CONSTRAINT на пару (ChatRoomId, UserId):
 * 
 *   entity.HasIndex(m => new { m.ChatRoomId, m.UserId })
 *       .IsUnique();
 * 
 * Это гарантирует, что один пользователь не может быть дважды в одной группе!
 * 
 * ============================================================================
 */
